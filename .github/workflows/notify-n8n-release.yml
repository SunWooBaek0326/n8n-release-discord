name: Notify n8n Releases to Discord

on:
  release:
    types: [published]        # 실시간: 릴리즈 공개 즉시
  schedule:
    - cron: "*/30 * * * *"    # 백업: 30분 폴링
  workflow_dispatch: {}       # 수동 실행(테스트용, 항상 전송)

permissions:
  contents: write             # .github/n8n_latest 커밋용

jobs:
  notify:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install jq and curl
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      # 0) Webhook 시크릿 확인
      - name: Validate webhook secret
        run: |
          if [ -z "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            echo "::error::Missing secret DISCORD_WEBHOOK_URL"
            exit 1
          fi

      # 1) Webhook 값 정규화 + 형식 점검
      - name: Normalize webhook value
        id: hook
        run: |
          CLEAN=$(printf "%s" "${{ secrets.DISCORD_WEBHOOK_URL }}" | tr -d '\r' | tr -d '\n' | xargs)
          case "$CLEAN" in
            https://discord.com/api/webhooks/*|https://discordapp.com/api/webhooks/*) : ;;
            *) echo "::error::Webhook URL looks invalid: $CLEAN"; exit 2 ;;
          esac
          echo "webhook=$CLEAN" >> "$GITHUB_OUTPUT"

      # 2) 이벤트 유형별 릴리즈 정보 준비 (멀티라인은 heredoc으로 출력)
      - name: Prepare release payload
        id: rel
        env:
          EVENT: ${{ github.event_name }}
        run: |
          set -e
          if [ "$EVENT" = "release" ]; then
            TAG='${{ github.event.release.tag_name }}'          # 예: n8n@1.110.1
            TITLE='${{ github.event.release.name }}'
            URL='${{ github.event.release.html_url }}'
            DATE='${{ github.event.release.published_at }}'
            BODY_RAW='${{ github.event.release.body }}'
          else
            RES=$(curl -s https://api.github.com/repos/n8n-io/n8n/releases/latest)
            TAG=$(echo "$RES"   | jq -r .tag_name)
            TITLE=$(echo "$RES" | jq -r .name)
            URL=$(echo "$RES"   | jq -r .html_url)
            DATE=$(echo "$RES"  | jq -r .published_at)
            BODY_RAW=$(echo "$RES" | jq -r .body)
          fi

          [ -z "$TITLE" -o "$TITLE" = "null" ] && TITLE="n8n @$TAG"
          DATE_SHORT=$(echo "$DATE" | cut -dT -f1)
          BODY_TRIM=$(printf "%s" "$BODY_RAW" | tr -d '\r' | sed 's/\x1b\[[0-9;]*m//g' | head -c 1800)
          [ "$BODY_TRIM" = "null" ] && BODY_TRIM=""

          echo "tag=$TAG"         >> "$GITHUB_OUTPUT"
          echo "title=$TITLE"     >> "$GITHUB_OUTPUT"
          echo "url=$URL"         >> "$GITHUB_OUTPUT"
          echo "date=$DATE_SHORT" >> "$GITHUB_OUTPUT"
          {
            echo "body<<__REL_BODY__"
            printf '%s\n' "$BODY_TRIM"
            echo "__REL_BODY__"
          } >> "$GITHUB_OUTPUT"

      # 3) npm dist-tags 조회 (latest, next)
      - name: Fetch npm dist-tags
        id: dist
        run: |
          JSON=$(curl -s https://registry.npmjs.org/-/package/n8n/dist-tags)
          LATEST=$(echo "$JSON" | jq -r .latest)   # 예: 1.110.1
          NEXT=$(echo "$JSON"   | jq -r .next)     # 예: 1.111.0
          echo "latest=$LATEST" >> "$GITHUB_OUTPUT"
          echo "next=$NEXT"     >> "$GITHUB_OUTPUT"

      # 4) 이전에 보낸 태그 읽기 (폴링/자동 시 중복 방지용)
      - name: Read previous tag
        id: prev
        run: |
          FILE=".github/n8n_latest"
          if [ -f "$FILE" ]; then PREV=$(cat "$FILE"); else PREV=""; fi
          echo "prev=$PREV" >> "$GITHUB_OUTPUT"

      # 5) 모드/중복 여부 및 채널+색상 판단
      - name: Decide sending mode & channel
        id: decide
        env:
          EVENT:  ${{ github.event_name }}
          PREV:   ${{ steps.prev.outputs.prev }}
          CURR:   ${{ steps.rel.outputs.tag }}         # 예: n8n@1.110.1
          LATEST: ${{ steps.dist.outputs.latest }}      # 예: 1.
